{"ast":null,"code":"/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport * as tslib_1 from \"tslib\";\nimport { Constants, PersistentCacheKeys, TemporaryCacheKeys, RequestStatus } from \"../utils/Constants\";\nimport { AccessTokenCacheItem } from \"./AccessTokenCacheItem\";\nimport { BrowserStorage } from \"./BrowserStorage\";\nimport { ClientAuthError } from \"../error/ClientAuthError\";\n/**\n * @hidden\n */\n\nvar AuthCache =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(AuthCache, _super);\n\n  function AuthCache(clientId, cacheLocation, storeAuthStateInCookie) {\n    var _this = _super.call(this, cacheLocation) || this;\n\n    _this.clientId = clientId; // This is hardcoded to true for now. We may make this configurable in the future\n\n    _this.rollbackEnabled = true;\n\n    _this.migrateCacheEntries(storeAuthStateInCookie);\n\n    return _this;\n  }\n  /**\n   * Support roll back to old cache schema until the next major release: true by default now\n   * @param storeAuthStateInCookie\n   */\n\n\n  AuthCache.prototype.migrateCacheEntries = function (storeAuthStateInCookie) {\n    var _this = this;\n\n    var idTokenKey = Constants.cachePrefix + \".\" + PersistentCacheKeys.IDTOKEN;\n    var clientInfoKey = Constants.cachePrefix + \".\" + PersistentCacheKeys.CLIENT_INFO;\n    var errorKey = Constants.cachePrefix + \".\" + PersistentCacheKeys.ERROR;\n    var errorDescKey = Constants.cachePrefix + \".\" + PersistentCacheKeys.ERROR_DESC;\n\n    var idTokenValue = _super.prototype.getItem.call(this, idTokenKey);\n\n    var clientInfoValue = _super.prototype.getItem.call(this, clientInfoKey);\n\n    var errorValue = _super.prototype.getItem.call(this, errorKey);\n\n    var errorDescValue = _super.prototype.getItem.call(this, errorDescKey);\n\n    var values = [idTokenValue, clientInfoValue, errorValue, errorDescValue];\n    var keysToMigrate = [PersistentCacheKeys.IDTOKEN, PersistentCacheKeys.CLIENT_INFO, PersistentCacheKeys.ERROR, PersistentCacheKeys.ERROR_DESC];\n    keysToMigrate.forEach(function (cacheKey, index) {\n      return _this.duplicateCacheEntry(cacheKey, values[index], storeAuthStateInCookie);\n    });\n  };\n  /**\n   * Utility function to help with roll back keys\n   * @param newKey\n   * @param value\n   * @param storeAuthStateInCookie\n   */\n\n\n  AuthCache.prototype.duplicateCacheEntry = function (newKey, value, storeAuthStateInCookie) {\n    if (value) {\n      this.setItem(newKey, value, storeAuthStateInCookie);\n    }\n  };\n  /**\n   * Prepend msal.<client-id> to each key; Skip for any JSON object as Key (defined schemas do not need the key appended: AccessToken Keys or the upcoming schema)\n   * @param key\n   * @param addInstanceId\n   */\n\n\n  AuthCache.prototype.generateCacheKey = function (key, addInstanceId) {\n    try {\n      // Defined schemas do not need the key appended\n      JSON.parse(key);\n      return key;\n    } catch (e) {\n      if (key.indexOf(\"\" + Constants.cachePrefix) === 0 || key.indexOf(PersistentCacheKeys.ADAL_ID_TOKEN) === 0) {\n        return key;\n      }\n\n      return addInstanceId ? Constants.cachePrefix + \".\" + this.clientId + \".\" + key : Constants.cachePrefix + \".\" + key;\n    }\n  };\n  /**\n   * add value to storage\n   * @param key\n   * @param value\n   * @param enableCookieStorage\n   */\n\n\n  AuthCache.prototype.setItem = function (key, value, enableCookieStorage) {\n    _super.prototype.setItem.call(this, this.generateCacheKey(key, true), value, enableCookieStorage);\n\n    if (this.rollbackEnabled) {\n      _super.prototype.setItem.call(this, this.generateCacheKey(key, false), value, enableCookieStorage);\n    }\n  };\n  /**\n   * get one item by key from storage\n   * @param key\n   * @param enableCookieStorage\n   */\n\n\n  AuthCache.prototype.getItem = function (key, enableCookieStorage) {\n    return _super.prototype.getItem.call(this, this.generateCacheKey(key, true), enableCookieStorage);\n  };\n  /**\n   * remove value from storage\n   * @param key\n   */\n\n\n  AuthCache.prototype.removeItem = function (key) {\n    _super.prototype.removeItem.call(this, this.generateCacheKey(key, true));\n\n    if (this.rollbackEnabled) {\n      _super.prototype.removeItem.call(this, this.generateCacheKey(key, false));\n    }\n  };\n  /**\n   * Reset the cache items\n   */\n\n\n  AuthCache.prototype.resetCacheItems = function () {\n    var storage = window[this.cacheLocation];\n    var key;\n\n    for (key in storage) {\n      // Check if key contains msal prefix; For now, we are clearing all cache items created by MSAL.js\n      if (storage.hasOwnProperty(key) && key.indexOf(Constants.cachePrefix) !== -1) {\n        _super.prototype.removeItem.call(this, key); // TODO: Clear cache based on client id (clarify use cases where this is needed)\n\n      }\n    }\n  };\n  /**\n   * Set cookies for IE\n   * @param cName\n   * @param cValue\n   * @param expires\n   */\n\n\n  AuthCache.prototype.setItemCookie = function (cName, cValue, expires) {\n    _super.prototype.setItemCookie.call(this, this.generateCacheKey(cName, true), cValue, expires);\n\n    if (this.rollbackEnabled) {\n      _super.prototype.setItemCookie.call(this, this.generateCacheKey(cName, false), cValue, expires);\n    }\n  };\n  /**\n   * get one item by key from cookies\n   * @param cName\n   */\n\n\n  AuthCache.prototype.getItemCookie = function (cName) {\n    return _super.prototype.getItemCookie.call(this, this.generateCacheKey(cName, true));\n  };\n  /**\n   * Get all access tokens in the cache\n   * @param clientId\n   * @param homeAccountIdentifier\n   */\n\n\n  AuthCache.prototype.getAllAccessTokens = function (clientId, homeAccountIdentifier) {\n    var _this = this;\n\n    var results = Object.keys(window[this.cacheLocation]).reduce(function (tokens, key) {\n      var keyMatches = key.match(clientId) && key.match(homeAccountIdentifier) && key.match(Constants.scopes);\n\n      if (keyMatches) {\n        var value = _this.getItem(key);\n\n        if (value) {\n          try {\n            var parseAtKey = JSON.parse(key);\n            var newAccessTokenCacheItem = new AccessTokenCacheItem(parseAtKey, JSON.parse(value));\n            return tokens.concat([newAccessTokenCacheItem]);\n          } catch (e) {\n            throw ClientAuthError.createCacheParseError(key);\n          }\n        }\n      }\n\n      return tokens;\n    }, []);\n    return results;\n  };\n  /**\n   * Remove all temporary cache entries\n   * @param state\n   */\n\n\n  AuthCache.prototype.removeAcquireTokenEntries = function (state) {\n    var storage = window[this.cacheLocation];\n    var key;\n\n    for (key in storage) {\n      if (storage.hasOwnProperty(key)) {\n        if ((key.indexOf(TemporaryCacheKeys.AUTHORITY) !== -1 || key.indexOf(TemporaryCacheKeys.ACQUIRE_TOKEN_ACCOUNT) !== 1) && (!state || key.indexOf(state) !== -1)) {\n          var resourceDelimSplitKey = key.split(Constants.resourceDelimiter);\n          var keyState = void 0;\n\n          if (resourceDelimSplitKey.length > 1) {\n            keyState = resourceDelimSplitKey[resourceDelimSplitKey.length - 1];\n          }\n\n          if (keyState === state && !this.tokenRenewalInProgress(keyState)) {\n            this.removeItem(key);\n            this.removeItem(TemporaryCacheKeys.RENEW_STATUS + state);\n            this.removeItem(TemporaryCacheKeys.STATE_LOGIN);\n            this.removeItem(TemporaryCacheKeys.STATE_ACQ_TOKEN);\n            this.removeItem(TemporaryCacheKeys.LOGIN_REQUEST);\n            this.removeItem(TemporaryCacheKeys.INTERACTION_STATUS);\n            this.removeItem(TemporaryCacheKeys.NONCE_IDTOKEN + \"|\" + state);\n            this.setItemCookie(key, \"\", -1);\n            this.clearMsalCookie(state);\n          }\n        }\n      }\n    }\n  };\n  /**\n   * Return if the token renewal is still in progress\n   * @param stateValue\n   */\n\n\n  AuthCache.prototype.tokenRenewalInProgress = function (stateValue) {\n    var renewStatus = this.getItem(TemporaryCacheKeys.RENEW_STATUS + stateValue);\n    return !!(renewStatus && renewStatus === RequestStatus.IN_PROGRESS);\n  };\n  /**\n   * Clear all cookies\n   */\n\n\n  AuthCache.prototype.clearMsalCookie = function (state) {\n    var nonceKey = state ? TemporaryCacheKeys.NONCE_IDTOKEN + \"|\" + state : TemporaryCacheKeys.NONCE_IDTOKEN;\n    this.clearItemCookie(nonceKey);\n    this.clearItemCookie(TemporaryCacheKeys.STATE_LOGIN);\n    this.clearItemCookie(TemporaryCacheKeys.LOGIN_REQUEST);\n    this.clearItemCookie(TemporaryCacheKeys.STATE_ACQ_TOKEN);\n  };\n  /**\n   * Create acquireTokenAccountKey to cache account object\n   * @param accountId\n   * @param state\n   */\n\n\n  AuthCache.generateAcquireTokenAccountKey = function (accountId, state) {\n    return \"\" + TemporaryCacheKeys.ACQUIRE_TOKEN_ACCOUNT + Constants.resourceDelimiter + accountId + Constants.resourceDelimiter + state;\n  };\n  /**\n   * Create authorityKey to cache authority\n   * @param state\n   */\n\n\n  AuthCache.generateAuthorityKey = function (state) {\n    return \"\" + TemporaryCacheKeys.AUTHORITY + Constants.resourceDelimiter + state;\n  };\n\n  return AuthCache;\n}(BrowserStorage);\n\nexport { AuthCache };","map":null,"metadata":{},"sourceType":"module"}