{"ast":null,"code":"import { ClientAuthError } from \"../error/ClientAuthError\";\nimport { UrlUtils } from \"./UrlUtils\";\n\nvar WindowUtils =\n/** @class */\nfunction () {\n  function WindowUtils() {}\n  /**\n   * @hidden\n   * Checks if the current page is running in an iframe.\n   * @ignore\n   */\n\n\n  WindowUtils.isInIframe = function () {\n    return window.parent !== window;\n  };\n  /**\n   * @hidden\n   * Check if the current page is running in a popup.\n   * @ignore\n   */\n\n\n  WindowUtils.isInPopup = function () {\n    return !!(window.opener && window.opener !== window);\n  };\n  /**\n   * @hidden\n   * Monitors a window until it loads a url with a hash\n   * @ignore\n   */\n\n\n  WindowUtils.monitorWindowForHash = function (contentWindow, timeout, urlNavigate) {\n    return new Promise(function (resolve, reject) {\n      var maxTicks = timeout / WindowUtils.POLLING_INTERVAL_MS;\n      var ticks = 0;\n      var intervalId = setInterval(function () {\n        if (contentWindow.closed) {\n          clearInterval(intervalId);\n          reject(ClientAuthError.createUserCancelledError());\n          return;\n        }\n\n        var href;\n\n        try {\n          /*\n           * Will throw if cross origin,\n           * which should be caught and ignored\n           * since we need the interval to keep running while on STS UI.\n           */\n          href = contentWindow.location.href;\n        } catch (e) {} // Don't process blank pages or cross domain\n\n\n        if (!href || href === \"about:blank\") {\n          return;\n        } // Only run clock when we are on same domain\n\n\n        ticks++;\n\n        if (UrlUtils.urlContainsHash(href)) {\n          clearInterval(intervalId);\n          resolve(contentWindow.location.hash);\n        } else if (ticks > maxTicks) {\n          clearInterval(intervalId);\n          reject(ClientAuthError.createTokenRenewalTimeoutError(urlNavigate)); // better error?\n        }\n      }, WindowUtils.POLLING_INTERVAL_MS);\n    });\n  };\n  /**\n   * @hidden\n   * Loads iframe with authorization endpoint URL\n   * @ignore\n   */\n\n\n  WindowUtils.loadFrame = function (urlNavigate, frameName, timeoutMs, logger) {\n    /*\n     * This trick overcomes iframe navigation in IE\n     * IE does not load the page consistently in iframe\n     */\n    logger.info(\"LoadFrame: \" + frameName);\n    return new Promise(function (resolve, reject) {\n      setTimeout(function () {\n        var frameHandle = WindowUtils.addHiddenIFrame(frameName, logger);\n\n        if (!frameHandle) {\n          reject(\"Unable to load iframe with name: \" + frameName);\n          return;\n        }\n\n        if (frameHandle.src === \"\" || frameHandle.src === \"about:blank\") {\n          frameHandle.src = urlNavigate;\n          logger.infoPii(\"Frame Name : \" + frameName + \" Navigated to: \" + urlNavigate);\n        }\n\n        resolve(frameHandle);\n      }, timeoutMs);\n    });\n  };\n  /**\n   * @hidden\n   * Adds the hidden iframe for silent token renewal.\n   * @ignore\n   */\n\n\n  WindowUtils.addHiddenIFrame = function (iframeId, logger) {\n    if (typeof iframeId === \"undefined\") {\n      return null;\n    }\n\n    logger.info(\"Add msal frame to document:\" + iframeId);\n    var adalFrame = document.getElementById(iframeId);\n\n    if (!adalFrame) {\n      if (document.createElement && document.documentElement && window.navigator.userAgent.indexOf(\"MSIE 5.0\") === -1) {\n        var ifr = document.createElement(\"iframe\");\n        ifr.setAttribute(\"id\", iframeId);\n        ifr.style.visibility = \"hidden\";\n        ifr.style.position = \"absolute\";\n        ifr.style.width = ifr.style.height = \"0\";\n        ifr.style.border = \"0\";\n        ifr.setAttribute(\"sandbox\", \"allow-scripts allow-same-origin\");\n        adalFrame = document.getElementsByTagName(\"body\")[0].appendChild(ifr);\n      } else if (document.body && document.body.insertAdjacentHTML) {\n        document.body.insertAdjacentHTML(\"beforeend\", \"<iframe name='\" + iframeId + \"' id='\" + iframeId + \"' style='display:none'></iframe>\");\n      }\n\n      if (window.frames && window.frames[iframeId]) {\n        adalFrame = window.frames[iframeId];\n      }\n    }\n\n    return adalFrame;\n  };\n  /**\n   * @hidden\n   * Removes a hidden iframe from the page.\n   * @ignore\n   */\n\n\n  WindowUtils.removeHiddenIframe = function (iframe) {\n    if (document.body !== iframe.parentNode) {\n      document.body.removeChild(iframe);\n    }\n  };\n  /**\n   * @hidden\n   * Find and return the iframe element with the given hash\n   * @ignore\n   */\n\n\n  WindowUtils.getIframeWithHash = function (hash) {\n    var iframes = document.getElementsByTagName(\"iframe\");\n    var iframeArray = Array.apply(null, Array(iframes.length)).map(function (iframe, index) {\n      return iframes.item(index);\n    }); // eslint-disable-line prefer-spread\n\n    return iframeArray.filter(function (iframe) {\n      try {\n        return iframe.contentWindow.location.hash === hash;\n      } catch (e) {\n        return false;\n      }\n    })[0];\n  };\n  /**\n   * @hidden\n   * Returns an array of all the popups opened by MSAL\n   * @ignore\n   */\n\n\n  WindowUtils.getPopups = function () {\n    if (!window.openedWindows) {\n      window.openedWindows = [];\n    }\n\n    return window.openedWindows;\n  };\n  /**\n   * @hidden\n   * Find and return the popup with the given hash\n   * @ignore\n   */\n\n\n  WindowUtils.getPopUpWithHash = function (hash) {\n    return WindowUtils.getPopups().filter(function (popup) {\n      try {\n        return popup.location.hash === hash;\n      } catch (e) {\n        return false;\n      }\n    })[0];\n  };\n  /**\n   * @hidden\n   * Add the popup to the known list of popups\n   * @ignore\n   */\n\n\n  WindowUtils.trackPopup = function (popup) {\n    WindowUtils.getPopups().push(popup);\n  };\n  /**\n   * @hidden\n   * Close all popups\n   * @ignore\n   */\n\n\n  WindowUtils.closePopups = function () {\n    WindowUtils.getPopups().forEach(function (popup) {\n      return popup.close();\n    });\n  };\n  /**\n   * @hidden\n   * Interval in milliseconds that we poll a window\n   * @ignore\n   */\n\n\n  WindowUtils.POLLING_INTERVAL_MS = 50;\n  return WindowUtils;\n}();\n\nexport { WindowUtils };","map":null,"metadata":{},"sourceType":"module"}