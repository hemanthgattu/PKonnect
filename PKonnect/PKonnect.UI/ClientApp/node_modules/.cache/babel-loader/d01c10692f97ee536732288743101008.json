{"ast":null,"code":"/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { Constants, SSOTypes, ServerHashParamKeys } from \"./Constants\";\nimport { ScopeSet } from \"../ScopeSet\";\nimport { StringUtils } from \"./StringUtils\";\nimport { CryptoUtils } from \"./CryptoUtils\";\n/**\n * @hidden\n */\n\nvar UrlUtils =\n/** @class */\nfunction () {\n  function UrlUtils() {}\n  /**\n   * generates the URL with QueryString Parameters\n   * @param scopes\n   */\n\n\n  UrlUtils.createNavigateUrl = function (serverRequestParams) {\n    var str = this.createNavigationUrlString(serverRequestParams);\n    var authEndpoint = serverRequestParams.authorityInstance.AuthorizationEndpoint; // if the endpoint already has queryparams, lets add to it, otherwise add the first one\n\n    if (authEndpoint.indexOf(\"?\") < 0) {\n      authEndpoint += \"?\";\n    } else {\n      authEndpoint += \"&\";\n    }\n\n    var requestUrl = \"\" + authEndpoint + str.join(\"&\");\n    return requestUrl;\n  };\n  /**\n   * Generate the array of all QueryStringParams to be sent to the server\n   * @param scopes\n   */\n\n\n  UrlUtils.createNavigationUrlString = function (serverRequestParams) {\n    var scopes = serverRequestParams.scopes;\n\n    if (scopes.indexOf(serverRequestParams.clientId) === -1) {\n      scopes.push(serverRequestParams.clientId);\n    }\n\n    var str = [];\n    str.push(\"response_type=\" + serverRequestParams.responseType);\n    this.translateclientIdUsedInScope(scopes, serverRequestParams.clientId);\n    str.push(\"scope=\" + encodeURIComponent(ScopeSet.parseScope(scopes)));\n    str.push(\"client_id=\" + encodeURIComponent(serverRequestParams.clientId));\n    str.push(\"redirect_uri=\" + encodeURIComponent(serverRequestParams.redirectUri));\n    str.push(\"state=\" + encodeURIComponent(serverRequestParams.state));\n    str.push(\"nonce=\" + encodeURIComponent(serverRequestParams.nonce));\n    str.push(\"client_info=1\");\n    str.push(\"x-client-SKU=\" + serverRequestParams.xClientSku);\n    str.push(\"x-client-Ver=\" + serverRequestParams.xClientVer);\n\n    if (serverRequestParams.promptValue) {\n      str.push(\"prompt=\" + encodeURIComponent(serverRequestParams.promptValue));\n    }\n\n    if (serverRequestParams.claimsValue) {\n      str.push(\"claims=\" + encodeURIComponent(serverRequestParams.claimsValue));\n    }\n\n    if (serverRequestParams.queryParameters) {\n      str.push(serverRequestParams.queryParameters);\n    }\n\n    if (serverRequestParams.extraQueryParameters) {\n      str.push(serverRequestParams.extraQueryParameters);\n    }\n\n    str.push(\"client-request-id=\" + encodeURIComponent(serverRequestParams.correlationId));\n    return str;\n  };\n  /**\n   * append the required scopes: https://openid.net/specs/openid-connect-basic-1_0.html#Scopes\n   * @param scopes\n   */\n\n\n  UrlUtils.translateclientIdUsedInScope = function (scopes, clientId) {\n    var clientIdIndex = scopes.indexOf(clientId);\n\n    if (clientIdIndex >= 0) {\n      scopes.splice(clientIdIndex, 1);\n\n      if (scopes.indexOf(\"openid\") === -1) {\n        scopes.push(\"openid\");\n      }\n\n      if (scopes.indexOf(\"profile\") === -1) {\n        scopes.push(\"profile\");\n      }\n    }\n  };\n  /**\n   * Returns current window URL as redirect uri\n   */\n\n\n  UrlUtils.getDefaultRedirectUri = function () {\n    return window.location.href.split(\"?\")[0].split(\"#\")[0];\n  };\n  /**\n   * Given a url like https://a:b/common/d?e=f#g, and a tenantId, returns https://a:b/tenantId/d\n   * @param href The url\n   * @param tenantId The tenant id to replace\n   */\n\n\n  UrlUtils.replaceTenantPath = function (url, tenantId) {\n    url = url.toLowerCase();\n    var urlObject = this.GetUrlComponents(url);\n    var pathArray = urlObject.PathSegments;\n\n    if (tenantId && pathArray.length !== 0 && (pathArray[0] === Constants.common || pathArray[0] === SSOTypes.ORGANIZATIONS)) {\n      pathArray[0] = tenantId;\n    }\n\n    return this.constructAuthorityUriFromObject(urlObject, pathArray);\n  };\n\n  UrlUtils.constructAuthorityUriFromObject = function (urlObject, pathArray) {\n    return this.CanonicalizeUri(urlObject.Protocol + \"//\" + urlObject.HostNameAndPort + \"/\" + pathArray.join(\"/\"));\n  };\n  /**\n   * Parses out the components from a url string.\n   * @returns An object with the various components. Please cache this value insted of calling this multiple times on the same url.\n   */\n\n\n  UrlUtils.GetUrlComponents = function (url) {\n    if (!url) {\n      throw \"Url required\";\n    } // https://gist.github.com/curtisz/11139b2cfcaef4a261e0\n\n\n    var regEx = RegExp(\"^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\\\?([^#]*))?(#(.*))?\");\n    var match = url.match(regEx);\n\n    if (!match || match.length < 6) {\n      throw \"Valid url required\";\n    }\n\n    var urlComponents = {\n      Protocol: match[1],\n      HostNameAndPort: match[4],\n      AbsolutePath: match[5]\n    };\n    var pathSegments = urlComponents.AbsolutePath.split(\"/\");\n    pathSegments = pathSegments.filter(function (val) {\n      return val && val.length > 0;\n    }); // remove empty elements\n\n    urlComponents.PathSegments = pathSegments;\n    return urlComponents;\n  };\n  /**\n   * Given a url or path, append a trailing slash if one doesnt exist\n   *\n   * @param url\n   */\n\n\n  UrlUtils.CanonicalizeUri = function (url) {\n    if (url) {\n      url = url.toLowerCase();\n    }\n\n    if (url && !UrlUtils.endsWith(url, \"/\")) {\n      url += \"/\";\n    }\n\n    return url;\n  };\n  /**\n   * Checks to see if the url ends with the suffix\n   * Required because we are compiling for es5 instead of es6\n   * @param url\n   * @param str\n   */\n  // TODO: Rename this, not clear what it is supposed to do\n\n\n  UrlUtils.endsWith = function (url, suffix) {\n    if (!url || !suffix) {\n      return false;\n    }\n\n    return url.indexOf(suffix, url.length - suffix.length) !== -1;\n  };\n  /**\n   * Utils function to remove the login_hint and domain_hint from the i/p extraQueryParameters\n   * @param url\n   * @param name\n   */\n\n\n  UrlUtils.urlRemoveQueryStringParameter = function (url, name) {\n    if (StringUtils.isEmpty(url)) {\n      return url;\n    }\n\n    var regex = new RegExp(\"(\\\\&\" + name + \"=)[^\\&]+\");\n    url = url.replace(regex, \"\"); // name=value&\n\n    regex = new RegExp(\"(\" + name + \"=)[^\\&]+&\");\n    url = url.replace(regex, \"\"); // name=value\n\n    regex = new RegExp(\"(\" + name + \"=)[^\\&]+\");\n    url = url.replace(regex, \"\");\n    return url;\n  };\n  /**\n   * @hidden\n   * @ignore\n   *\n   * Returns the anchor part(#) of the URL\n   */\n\n\n  UrlUtils.getHashFromUrl = function (urlStringOrFragment) {\n    var hashIndex1 = urlStringOrFragment.indexOf(\"#\");\n    var hashIndex2 = urlStringOrFragment.indexOf(\"#/\");\n\n    if (hashIndex2 > -1) {\n      return urlStringOrFragment.substring(hashIndex2 + 2);\n    } else if (hashIndex1 > -1) {\n      return urlStringOrFragment.substring(hashIndex1 + 1);\n    }\n\n    return urlStringOrFragment;\n  };\n  /**\n   * @hidden\n   * Check if the url contains a hash with known properties\n   * @ignore\n   */\n\n\n  UrlUtils.urlContainsHash = function (urlString) {\n    var parameters = UrlUtils.deserializeHash(urlString);\n    return parameters.hasOwnProperty(ServerHashParamKeys.ERROR_DESCRIPTION) || parameters.hasOwnProperty(ServerHashParamKeys.ERROR) || parameters.hasOwnProperty(ServerHashParamKeys.ACCESS_TOKEN) || parameters.hasOwnProperty(ServerHashParamKeys.ID_TOKEN);\n  };\n  /**\n   * @hidden\n   * Returns deserialized portion of URL hash\n   * @ignore\n   */\n\n\n  UrlUtils.deserializeHash = function (urlFragment) {\n    var hash = UrlUtils.getHashFromUrl(urlFragment);\n    return CryptoUtils.deserialize(hash);\n  };\n\n  return UrlUtils;\n}();\n\nexport { UrlUtils };","map":null,"metadata":{},"sourceType":"module"}